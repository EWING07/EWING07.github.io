<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OWASP TPO10 漏洞和防范</title>
    <link href="/2020/03/18/OWASP-TPO10-%E6%BC%8F%E6%B4%9E%E5%92%8C%E9%98%B2%E8%8C%83/"/>
    <url>/2020/03/18/OWASP-TPO10-%E6%BC%8F%E6%B4%9E%E5%92%8C%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-注入-Injection"><a href="#1-注入-Injection" class="headerlink" title="1. 注入 Injection"></a>1. 注入 Injection</h2><p>Web安全头号大敌。注入攻击漏洞往往是应用程序缺少对输入进行安全性检查所引起的。攻击者把一些包含攻击代码当做命令或者查询语句发送给解释器，这些恶意数据可以欺骗解释器，从而执行计划外的命令或者未授权访问数据。注入漏洞通常能SQL查询、LDAP查询、OS命令、程序参数等中出现。</p><h4 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h4><ul><li>使用安全的API，避免使用解释器或提供参数化的接口（prepared statements， or stored procedures)</li><li>使用白名单来规范化的输入验证方法</li><li>对输入的特殊字符进行Escape转义处理</li><li>权限最小化，减轻被注入的影响</li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>为了防止注入攻击，首先需要合理校验输入。在服务端，这可以由编写我们自己的校验流程来实现，但是最佳选择是使用语言自己的校验流程，因为它们更加广泛使用并测试过。一个极好的激励就是 PHP 中的<code>filter_var</code>，或者 ASP.NET 中的 校验助手。例如，PHP 中的邮箱校验类似于</p><pre><code class="php">  function isValidEmail($email){      return filter_var($email, FILTER_VALIDATE_EMAIL);  }</code></pre></li><li><p>在客户端，检验可以由创建 JavaScript 校验函数来完成，使用正则表达式。例如，邮箱检验流程是：</p><pre><code class="JavaScript">  function isValidEmail (input) {       var result=false;       var email_regex = /^[a-zA-Z0-9._-]+@([a-zA-Z0-9.-]+\.)+[azA-Z0-9.-]{2,4}$/;       if ( email_regex.test(input) ) {           result = true;       }       return result;   }</code></pre></li><li><p>对于 SQL 注入，避免拼接输入值为查询十分关键。反之，使用参数化查询。</p><p>  如：Java：</p><pre><code>  String custname =  request.getParameter(&quot;customerName&quot;);   String query = &quot;SELECT account_balance FROM user_data WHERE user_ name =? &quot;;   PreparedStatement pstmt = connection.prepareStatement( query );   pstmt.setString( 1, custname);   ResultSet results = pstmt.executeQuery( );</code></pre></li><li><p>考虑注入出现的时机，对减少可能的损失总量也有帮助。所以，使用低权限的系统用户来运行数据库和 Web 服务器。</p></li><li><p>确保输入用于连接数据库服务器的用户不是数据库管理员。</p></li><li><p>禁用甚至删除允许攻击者执行系统命令或提权的储存过程，例如 MSSQL 服务器中的<code>xp_cmdshell</code>。</p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>预防任何类型代码注入攻击的主要部分永远是合理的输入校验，位于服务端也位于客户端。</p><p>对于 SQL 注入，始终使用参数化或者预编译查询。而不是拼接 SQL 语句和输入。参数化查询将函数参数插入到 SQL 语句特定的位置，消除了程序员通过拼接构造查询的需求。</p><p>这个秘籍中，我们使用了语言内建的校验函数，但是如果你需要校验一些特殊类型的参数，你可以通过使用正则表达式创建自己的版本。</p><p>除了执行正确校验，我们也需要在一些人蓄意注入一些代码的情况下，降低沦陷的影响。这可以通过在操作系统的上下文中为 Web 服务器合理配置用户权限，以及在数据库服务器上下文中配置数据库和 OS 来实现。</p><h2 id="2-失效的身份认证和会话管理-Broken-Authentication-and-Session-Management"><a href="#2-失效的身份认证和会话管理-Broken-Authentication-and-Session-Management" class="headerlink" title="2. 失效的身份认证和会话管理  Broken Authentication and Session Management"></a>2. 失效的身份认证和会话管理  Broken Authentication and Session Management</h2><p>与认证和会话管理相关的应用程序功能往往得不到正确管理，这就导致攻击者破话密码、密匙、会话令牌或利用实施漏洞冒充其他用户身份</p><h4 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h4><p>使用强大的认证和会话管理控制-OWASP的应用安全验证标准</p><ul><li>使用简单集中标准化的认证方式</li><li>确保SSL在任何时候都会保护会话</li><li>使用会话管理功能</li></ul><p>会话管理：当用户不操作时，系统必须自动终止超时会话，必须有时间限制；必须提供退出功能，允许用户强制退出会话；会话标识足够随机，防止攻击者猜测到标识；用户登录后必须分配新的会话标识，不使用用户未登录前所使用的标识，防止会话攻击</p><h4 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>如果应用中存在只能由授权用户查看的页面、表单或者任何信息片段，确保在展示它们之前存在合理的身份验证。</li><li>确保用户名、ID、密码和所有其它身份验证数据是大小写敏感的，并且对每个用户唯一。</li><li>建立强密码策略，强迫用户创建至少满足下列条件的密码：<ul><li>对于 8 个字符，推荐 10 个。</li><li>使用大写和小写字母。</li><li>至少使用一个数字。</li><li>至少使用一个特殊字符（空格、!、&amp;、#、%，以及其它）。</li><li>禁止用户名、站点名称、公司名称或者它们的变体（大小写转换、l33t、它们的片段）用于密码。</li><li>禁止使用“常见密码”列表中的密码：<a href="https://www.teamsid.com/worst-passwords-2015/" target="_blank" rel="noopener">https://www.teamsid.com/worst-passwords-2015/ </a></li><li>永远不要显示用户是否存在或者信息格式是否正确的错误信息。对不正确的登录请求、不存在的用户、名称或密码不匹配模式、以及所有可能的登录错误使用相同的泛化信息。这种信息类似于<ul><li>登录数据不正确。</li><li>用户名或密码无效。</li><li>访问禁止。</li></ul></li></ul></li><li>密码不能以纯文本格式储存在数据库中。使用强哈希算法，例如 SHA-2、scrypt、或者 bcrypt，它们特别为难以使用 GPU 破解而设计。</li><li>在对比用户输入和密码时，计算输入的哈希之后比较哈希之后的字符串。永远不要解密密码来使用纯文本用户输入来比较。</li><li>避免基本的 HTML 身份验证。</li><li>可能的话，使用多因素验证（MFA），这意味着使用不止一个身份验证因素来登录：<ul><li>一些你知道的（账户信息或密码）</li><li>一些你拥有的（标识或手机号）</li><li>一些你的特征（生物计量）</li></ul></li><li>如果可能的话，实现证书、预共享密钥、或其它无需密码的身份校验协议（OAuth2、OpenID、SAML、或者 FIDO）。</li><li>对于会话管理，推荐使用语言内建的会话管理系统，Java、ASP.NET和 PHP。它们并不完美，但是能够确保提供设计良好和广泛测试的机制，而且比起开发团队在时间紧迫情况下的自制版本，它们更易于实现。</li><li>始终为登录和登录后的页面使用 HTTPS – 显然，要防止只接受 SSL 和 TLS v1.1 连接。</li><li>为了确保 HTTPS 能够生效，可以使用 HSTS。它是由 Web 应用指定的双向选择的特性。通过 Strict-Transport-Security 协议头，它在 http://<br>存在于 URL 的情况下会重定向到安全的选项，并防止“无效证书”信息的覆写。例如使用 Burp Suite 的时候会出现的情况。更多信息请见：<a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">https://www.owasp.org/index.php/HTTP_Strict_Transport_Security</a></li><li>设置 HTTPOnly 和安全的 Cookie 属性。</li><li>设置最少但实际的会话过期时间。确保正常用户离开之后，攻击者不能复用会话，并且用户能够执行应用打算执行的操作。</li></ul><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>身份校验机制通常在 Web 应用中简化为用户名/密码登录页面。虽然并不是最安全的选择，但它对于用户和开发者最简单，以及当密码被盗取时，最重要的层面就是它们的强度。</p><p>我们可以从这本书看到，密码强度由破解难度决定，通过爆破、字典或猜测。这个秘籍的第一个提示是为了使密码更难以通过建立最小长度的混合字符集来破解，难以通过排除更直觉的方案（用户名、常见密码、公司名称）来猜测，并且通过使用强哈希或加密储存，难以在泄露之后破解。</p><p>对于会话管理来说，过期时间、唯一性和会话 ID 的强度（已经在语言内建机制中实现），以及 Cookie 设置中的安全都是关键的考虑因素。</p><p>谈论身份校验安全的最重要的层面是，如果消息可以通过中间人攻击拦截或者服务，没有任何安全配置、控制或强密码是足够安全的。所以，合理配置的加密通信频道的使用，例如 TLS，对保护我们的用户身份数据来说极其重要。</p><h2 id="3-跨站脚本-XSS"><a href="#3-跨站脚本-XSS" class="headerlink" title="3. 跨站脚本-XSS"></a>3. 跨站脚本-XSS</h2><p>XSS的出现时间跟SQL差不多，是最普遍的web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证或转译，就会导致跨站脚本漏洞。XSS允许攻击者在受害者的浏览器中执行脚本，这些脚本可以劫持用户会话，破坏网站，或将用户重定向到恶意站点。</p><h4 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h4><ul><li>对所有不可信的输入数据进行恰当的转义escape</li><li>使用白名单的具有恰当的规范化解码功能的输入验证方法</li><li>使用内容安全策略（CSP）来抵御整个站点的攻击</li></ul><h4 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>应用存在 XSS 漏洞的第一个标志是，页面准确反映了用户提供的输入。所以，尝试不要使用用户提供的信息来构建输出文本。</p></li><li><p>当你需要将用户提供的信息放在输出页面上时，校验这些数据来防止任何类型代码的插入。我们已经在 A1 中看到如何实现它。</p></li><li><p>出于一些原因，如果用户被允许输入特殊字符或者代码段，在它插入到输出之前，过滤或合理编码文本。</p></li><li><p>对于过滤，在 PHP 中，可以使用filter_var。例如，如果你想让字符串为邮件地址：</p><pre><code class="php">  $email = &quot;john(.doe)@exa//mple.com&quot;;   $email = filter_var($email, FILTER_SANITIZE_EMAIL);   echo $email;</code></pre></li><li><p>在 .NET 中，对于 4.5 及更高版本，System.Web.Security.AntiXss<br>命名空间提供了必要的工具。对于 .NET 框架 4 及之前的版本，你可以使用 Web 保护库：<a href="http://wpl.codeplex.com/" target="_blank" rel="noopener">http://wpl.codeplex.com/</a></p></li><li><p>同样，为了防止储存型 XSS，在储存进数据库或从数据库获取之前，编码或过滤每个信息片段。</p></li><li><p>不要忽略头部、标题、CSS和页面的脚本区域，因为它们也可以被利用。</p></li></ul><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p>除了合理的输入校验，以及不要将用户输入用作输出信息，过滤和编码也是防止 XSS 的关键层面。</p><p>过滤意味着从字符串移除不允许的字符。这在输入字符串中存在特殊字符时很实用。</p><p>编码将特殊字符转换为 HTML 代码表示。例如，<code>&amp;</code>变为<code>&amp;amp</code>、<code>&lt;</code>变为<code>&amp;lt</code>。一些应用允许在输入字符串中使用特殊字符，对它们来说过滤不是个选择。所以应该在将输入插入页面，或者储存进数据库之前编码输入。</p><h2 id="4-不安全的直接对象引用-Insecurity-Direct-Object-Reference"><a href="#4-不安全的直接对象引用-Insecurity-Direct-Object-Reference" class="headerlink" title="4. 不安全的直接对象引用 Insecurity Direct Object Reference"></a>4. 不安全的直接对象引用 Insecurity Direct Object Reference</h2><p>当开发人员公开对内部实现对象（如文件、目录或数据库键）的引用时，就会出现直接对象引用。如果没有访问控制检查或其他保护，攻击者可以操纵这些引用来访问未经授权的数据</p><h4 id="防范：-1"><a href="#防范：-1" class="headerlink" title="防范："></a>防范：</h4><ul><li>使用基于用户或会话的间接对象访问，防止攻击者直接攻击未授权资源。</li><li>访问检查：对任何来自不受信源所使用直接对象引用都进行访问控制检测，确保用户对要求的对象有访问权限。</li></ul><h4 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>使用非直接引用优于直接引用。例如，不要通过参数中的名称来引用页面（<code>URL?page=&quot;restricted_page&quot;</code>），而是要创建索引，并在内部处理它（<code>URL?page=2</code>）。</li><li>将非直接引用映射到用户（会话）层面，于是用户仅仅能够访问授权的对象，即使它们修改了下标。</li><li>在传递相应对象之前校验引用，如果请求的用户没有权限来访问，展示通用错误页面。</li><li>输入校验也是很重要的，尤其是目录遍历和文件包含的情况下。</li><li>永远不要采取“隐藏式安全”的策略。如果有些文件包含受限的信息，即使它没有引用，有些人也会把它翻出来。</li></ul><h4 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h4><p>不安全对象的直接引用在 Web 应用中的表现形式有所不同，从目录遍历到敏感的 PDF 文档的引用。但是它们的大多数都依赖于一个假设，即用户永远不会找到方法来访问不能显式访问的东西。</p><p>为了防止这种漏洞，需要在设计和开发期间执行一些积极操作。设计可靠授权机制，来验证尝试访问一些信息的用户的关键是，是否用户真正允许访问它。</p><p>将引用对象映射为下标来避免对象名称直接用于参数值（就像 LFI 中的那样）是第一步。攻击者也可以修改下标，这很正常，就像对对象名称所做的那样。但是数据库中存在下标-对象的表的话，添加字段来规定访问所需的权限级别，比起没有任何表并且直接通过名称来访问资源，要容易得多。</p><p>之前说过，下标的表可能包含访问对象所需的权限级别，更加严格的话还有拥有者的 ID。所以，它只能够在请求用户是拥有者的情况下访问。</p><p>最后，输入校验必须存在于 Web 应用安全的每个层面。</p><h2 id="5-安全配置错误-Security-Misconfiguration"><a href="#5-安全配置错误-Security-Misconfiguration" class="headerlink" title="5.安全配置错误 Security Misconfiguration"></a>5.安全配置错误 Security Misconfiguration</h2><p>良好的安全性需要为应用程序、框架、应用服务器、web服务器、数据库服务器和平台定义和部署安全配置。默认值通常是不安全的。另外，软件应该保持更新。攻击者通过访问默认账户、未使用的网页、未安装补丁的漏洞、未被保护的文件和目录，以获得对系统未授权的访问。</p><h4 id="防范：-2"><a href="#防范：-2" class="headerlink" title="防范："></a>防范：</h4><ul><li>及时了解并部署每个环节的软件更新和补丁信息，包括所有的代码库。（自动化安装部署）</li><li>统一出错处理机制，错误处理会向用户显示堆栈跟踪或其他过于丰富的错误信息。</li><li>使用提供有效分离和安全性强大的应用程序架构</li></ul><h4 id="操作步骤-4"><a href="#操作步骤-4" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>可能的话，删除所有管理员应用，例如 Joomla 的 admin，WordPress 的 admin，PhpMyAdmin，或者 Tomcat Manager。如果不能这样，使它们只能从本地网络访问，例如，在 Apache 服务器中禁止来自外部网络的 PhpMyAdmin 访问，修改httd.conf文件（或者相应的站点配置文件）</li><li>修改所有 CMS、应用、数据库、服务器和框架的所有管理员密码，使其强度足够。</li><li>禁用所有不必要或未使用的服务器和应用特性。从日常或每周来看，新的漏洞都出现在 CMS 的可选模块和插件中。如果你的应用不需要它们，就不要激活它们。</li><li>始终执行最新的安全补丁和更新。在生成环境，建立测试环境来预防使站点不工作的缺陷十分重要，因为新版本存在一些兼容性及其它问题。</li><li>建立不会泄露跟踪信息、软件版本、程序组件名称，或任何其它调试信息的自定义的错误页面。如果开发者需要跟踪错误记录或者一些一些标识符对于技术支持非常必要，创建带有简单 ID 和错误描述的索引，并只展示 ID 给用户。所以当错误报告给相关人士的时候，它们会检查下标并且知道发生了什么错误。</li><li>采取“最小权限原则”。每个用户在每个层面（操作系统、数据库、或应用）上都应该只能够严格访问正确操作所需的信息。</li><li>使用上一个要点来考虑账户，构建安全配置的原则，并且将其应用到每个新的实现、更新或发布以及当前系统中。</li><li>强制定期的安全测试或审计，来帮助检测错误配置或遗漏的补丁。</li></ul><h4 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h4><p>谈论安全和配置问题时，“细节决定成败”十分恰当。web 服务器、数据库服务器、CMS、或者应用配置应该在完全可用和实用、以及保护用户和拥有者之间取得平衡。</p><p>Web 应用的一个常见错误配置就是一些 Web 管理站点对整个互联网都可见。这看起来并不是个大问题，但是我们应该知道，管理员登录页面更容易吸引攻击者，因为它可以用于获得高级权限等级，并且任何 CMS、数据或者站点管理工具都存在已知的常用默认密码列表。所以，我们强烈推荐不要把这些管理站点暴露给外部，并且尽可能移除它们。</p><p>此外，强密码的使用，以及修改默认密码（即使它们是强密码），在发布应用到公司内部网络，以及互联网的时候需要强制执行。当今，当我们将服务器开放给外部的时候，它收到的第一个流量就是端口扫描，登录页面请求，以及登录尝试，甚至在第一个用户知道该应用之前。</p><p>自定义错误页面的使用有助于安全准备，因为 Web 服务器和应用中的默认的错误信息展示太多的信息（从攻击者角度），它们关于错误、所使用的编程语言、栈回溯、所使用的数据库、操作系统以及其它。这些信息不应该暴露，因为它会帮助我们理解应用如何构建，并且提供所使用软件的版本和名称。攻击者通过这些信息就可以搜索已知漏洞，并构造更加有效的攻击过程。</p><p>一旦我们的服务器上的部署应用和所有服务都正确配置，我们就可以制订安全原则并且将其应用于所有要配置的新服务器或者已更新的服务器，或者当前带有合理规划的生产服务器。</p><p>这个配置原则需要持续测试，以便改进它以及持续保护新发现的漏洞。</p><h2 id="6-敏感信息泄露-Sensitive-Data-Exposure"><a href="#6-敏感信息泄露-Sensitive-Data-Exposure" class="headerlink" title="6. 敏感信息泄露 Sensitive Data Exposure"></a>6. 敏感信息泄露 Sensitive Data Exposure</h2><p>保护与加密敏感数据已经成为网络应用的最重要的组成部分。最常见的漏洞是应该进行加密的数据没有进行加密。使用加密的情况下常见问题是不安全的密钥和使用弱算法加密。</p><h4 id="防范：-3"><a href="#防范：-3" class="headerlink" title="防范："></a>防范：</h4><ul><li>加密存储和传输所有的敏感数据</li><li>确保使用合适强大的标准算法和密钥，并且密钥管理到位</li><li>确保使用密码专用算法存储密码</li><li>及时清除没有必要存放的重要的/敏感数据</li><li>禁用自动收集敏感数据，禁用包含敏感数据的页面缓存</li><li>加密方法：采用非对称加密算法管理对加密算法密钥，用对称加密算法加密数据</li></ul><h4 id="操作步骤-5"><a href="#操作步骤-5" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>如果你使用的敏感数据可以在使用之后删除，那么删除它。最好每次使用信用卡的时候询问用户，避免被盗取。</p></li><li><p>在处理支付的时候，始终使用支付网关，而不是在你的服务器中储存数据。</p></li><li><p>如果我们需要储存敏感数据，我们要采取的第一个保护就是使用强密码算法和相应的强密钥来加密。推荐 Twofish、AES、RSA 和三重 DES。</p></li><li><p>密码储存在数据库的时候，应该以单项哈希函数的哈希形式存储，例如，bcypt、scrypt 或 SHA-2。</p></li><li><p>确保所有敏感文档只能被授权用户访问。不要在 Web 服务器的文档根目录储存它们，而是在外部目录储存，并通过程序来访问。如果出于某种原因必须在服务器的文档根目录储存敏感文件，使用<code>.htaccess</code>文件来防止直接访问：</p><pre><code>  Order deny, allow  Deny from all</code></pre></li><li><p>禁用包含敏感数据的页面缓存。例如，在 Apache 中我们可以禁用 PDF 和 PNG 的缓存，通过<code>httpd.conf</code>中的下列设置：</p><pre><code>  &lt;FilesMatch &quot;\.(pdf|png)&gt;   FileETag None   Header unset ETag   Header set Cache-Control &quot;max-age=0, no-cache, no-store, mustrevalidate&quot;   Header set Pragma &quot;no-cache&quot;   Header set Expires &quot;Wed, 11 Jan 1984 05:00:00 GMT&quot;   &lt;/FilesMatch&gt;</code></pre></li><li><p>如果你允许文件上传，始终使用安全的通信频道来传输敏感数据，也就是带有 TLS 的 HTTPS，或者 FTPS（SSH 上的 FTP）。</p></li></ul><h4 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h4><p>对于保护敏感数据，我们需要最小化数据泄露或交易的风险。这就是正确加密储存敏感数据，以及保护加密密钥是所做的第一件事情的原因。如果可能不需要储存这类数据，这只是个理想选择。</p><p>密码应该使用单向哈希算法，在将它们储存到数据之前计算哈希。所以，即使它们被盗取，攻击者也不能立即使用它们，并且如果密码强度足够，哈希也是足够强的算法，它就不会在短时间内被破解。</p><p>如果我们在 Apache 服务器的文档根目录（<code>/var/ www/html/</code>）储存敏感文档或数据，我们就通过 URL 将这些信息暴露用于下载。所以，最好将它储存到别的地方，并编写特殊的服务端代码来在必要时获取它们，并带有预先的授权检查。</p><p>此外，例如 Archive.org、WayBackMachine 或者 Google 缓存页面，可能在缓存含有敏感信息的文件时，以及我们没能在应用的上一个版本有效保护它们时产生安全问题。所以，不允许缓存此类文档非常重要。</p><h2 id="7-缺少功能级访问控制"><a href="#7-缺少功能级访问控制" class="headerlink" title="7. 缺少功能级访问控制"></a>7. 缺少功能级访问控制</h2><p>大多数web应用程序在实现UI中可见的功能之前，都要验证功能级别的访问权限。但是，当访问每个函数时，应用程序需要在服务器上执行相同的访问控制检查。如果请求没有得到验证，攻击者将能够伪造请求，以便在没有适当授权的情况下访问功能。</p><h4 id="防范：-4"><a href="#防范：-4" class="headerlink" title="防范："></a>防范：</h4><ul><li>检查管理权限的过程并确保能够容易进行升级和审计，切忌硬编码。</li><li>默认缺省情况下，应该拒绝所有访问的执行权限</li><li>对于每个功能的访问，需要明确的角色授权。检查每个功能分配的权限合理有效</li></ul><h4 id="操作步骤-6"><a href="#操作步骤-6" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>确保每一步都正确检查了工作流的权限。</li><li>禁止所有默认访问，之后在显示的授权校验之后允许访问。</li><li>用户、角色和授权应该在灵活的媒介中储存，例如数据库或者配置文件，不要硬编码它们。</li><li>同样，“隐藏式安全”不是很好的策略。</li></ul><h4 id="工作原理-6"><a href="#工作原理-6" class="headerlink" title="工作原理"></a>工作原理</h4><p>开发者只在工作流的开始检查授权，并假设下面的步骤都已经对用户授权，这是常见的现象。攻击者可能会尝试调用某个功能，它是工作流的中间步骤，并由于控制缺失而能够访问它。</p><p>对于权限，默认禁止所有用户是个最佳实践。如果我们不知道一些用户是否有权访问一些功能，那么它们就不应该执行。将你的权限表转化为授权表。如果某些用户在某些功能上没有显式的授权，则禁止它们的访问。</p><p>在为你的应用功能构建或实现访问控制机制的时候，将所有授权储存在数据库中，或者在配置文件中（数据库是最好的选项）。如果用户角色和权限被硬编码，它们就会难以维护、修改或更新。</p><h2 id="8-跨站请求伪造CSRF"><a href="#8-跨站请求伪造CSRF" class="headerlink" title="8. 跨站请求伪造CSRF"></a>8. 跨站请求伪造CSRF</h2><p>利用了网站允许攻击者预测特定操作的所有细节这一特点。由于浏览器自动发送会话cookie等认证凭证，导致攻击者能够创建恶意的web页面来伪造请求。这些伪造请求很难和合法的请求区分开。CSRF通过伪装来自受信任用户的请求来利用受信任的网站</p><h4 id="防范：-5"><a href="#防范：-5" class="headerlink" title="防范："></a>防范：</h4><ul><li>给每个HTTP请求添加一个不可预测的令牌，并保证该令牌对每个用户会话来说是唯一性。最好是将独有的令牌包含在隐藏字段中，通过HTTP请求发送，避免在URL中暴露出来。</li><li>要去用户重新认证或者判断他们是一个真实的用户</li></ul><h4 id="操作步骤-7"><a href="#操作步骤-7" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>第一步也是最实际的 CSRF 解决方案就是实现唯一、操作层面的标识。所以每次用户尝试执行某个操作的时候，会生成新的标识并在服务端校验。</li><li>唯一标识应该不能被轻易由攻击者猜测，所以它们不能将其包含在 CSRF 页面中。随机生成是个好的选择。</li><li>在每个可能为 CSRF 目标的表单中包含要发送的标识。“添加到购物车”请求、密码修改表单、邮件、联系方式或收货信息管理，以及银行的转账页面都是很好的例子。</li><li>标识应该在每次请求中发送给服务器。这可以在 URL 中实现，或者任何其它变量或者隐藏字段，都是推荐的。</li><li>验证码的使用也可以防止 CSRF。</li><li>同样，在一些关键操作中询问重新授权也是个最佳实践，例如，银行应用中的转账操作。</li></ul><h4 id="工作原理-7"><a href="#工作原理-7" class="headerlink" title="工作原理"></a>工作原理</h4><p>防止 CSRF 完全是确保验证过的用户是请求操作的人。由于浏览器和 Web 应用的工作方式，最佳实践是使用标识来验证操作，或者可能的情况下使用验证码来控制。</p><p>由于攻击者打算尝试破解标识的生成，或者验证系统，以一种攻击者不能猜测的方式，安全地生成它们非常重要。而且要使它们对每个用户和每个操作都唯一，因为复用它们会偏离它们的目的。</p><p>验证码控制和重新授权有时候会非常麻烦，使用户反感。但是如果操作的重要性值得这么做，用户可能愿意接受它们来换取额外的安全级别。</p><h2 id="9-使用含有已知漏洞的组件"><a href="#9-使用含有已知漏洞的组件" class="headerlink" title="9. 使用含有已知漏洞的组件"></a>9. 使用含有已知漏洞的组件</h2><p>开发人员使用的组件也会含有漏洞，这些漏洞能够被自动化工具发现和利用。然后攻击者根据需要定制攻击代码并实施攻击。</p><h4 id="防范：-6"><a href="#防范：-6" class="headerlink" title="防范："></a>防范：</h4><ul><li>标识正在使用的所有组件和版本，包括所有依赖项</li><li>及时关注这些组件的安全信息并保证他们是最新的。</li><li>建立使用组件的安全策略，禁止使用未经安全评估的组件。</li><li>在适当情况下，对组件进去安全封装，精简不必要的功能。封装易受攻击的部分</li></ul><h4 id="操作步骤-8"><a href="#操作步骤-8" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>第一个建议是，优先选择受支持和广泛使用的知名软件。</li><li>为你的应用所使用的三方组件保持安全更新和补丁的更新。</li><li>用于搜索一些特定组件的漏洞的好地方就是厂商的网站：它们通常拥有“发布说明”部分，其中它们会公布它们纠正了哪个 bug 或漏洞。这里我们可以寸照我们所使用的（或更新的）版本，并且插件是否有有已知的问题没有打补丁。</li><li>同样，厂商通常拥有安全建议站点，例如 <a href="https://technet.microsoft.com/library/security/" target="_blank" rel="noopener">Microsoft</a>，<a href="https://developer.joomla.org/security-centre.html" target="_blank" rel="noopener">Joomla</a>，<a href="http://www.oracle.com/technetwork/topics/security/alerts-086861.html" target="_blank" rel="noopener">Oracle</a>。我们可以使用它们来保持我们用于应用的软件的更新。</li><li>也有一些厂商无关的站点，它们致力于通知我们漏洞和安全问题。有个非常好的网站，集中了多个来源的信息，是<a href="http://www.cvedetails.com/" target="_blank" rel="noopener">CVE Details</a>。这里我们可以搜索多数厂商或产品，或者列出所有已知漏洞（至少是拥有 CVE 号码的漏洞），并且按照年份、版本和 CVSS 分数排列。</li><li>同时，黑客发布利用和发现的站点也是个获得漏洞和我们所使用的软件的信息的好地方。最流行的是 <a href="https://www.exploit-db.com/" target="_blank" rel="noopener">Exploit DB</a>。 <a href="http://seclists.org/fulldisclosure/" target="_blank" rel="noopener">Full disclosure 邮件列表</a>，以及 <a href="https://packetstormsecurity.com/files/" target="_blank" rel="noopener">Packet Storm 的文件部分</a>。</li><li>一旦我们发现了我们软件组件中的漏洞，我们必须评估它是否对我们的应用必要，或者需要移除。如果不能这样，我们需要尽快打补丁。如果没有可用的补丁或变通方案，并且漏洞是高危的，我们必须开始寻找组件的替代。</li></ul><h4 id="工作原理-8"><a href="#工作原理-8" class="headerlink" title="工作原理"></a>工作原理</h4><p>考虑在我们的应用中使用三方软件组件之前，我们需要查看它的安全信息，并了解，我们所使用的组件是否有更稳定更安全的版本或替代。</p><p>一旦我们选择了某个，并且将其包含到我们的应用中，我们需要使其保持更新。有时它可能涉及到版本改动以及没有后向兼容，但是这是我们想要维持安全的代价。如果我们不能更新或为高危漏洞打补丁，我们还可以使用 WAF（Web 应用防火墙）和IPS（入侵检测系统）来防止攻击。</p><p>除了在执行渗透测试的时候比较实用，下载和漏洞发布站点可以被系统管理员利用，用于了解可能出现什么攻击，它们的原理，以及如何保护应用避免它们。</p><h2 id="10-未验证的重定向和转发"><a href="#10-未验证的重定向和转发" class="headerlink" title="10. 未验证的重定向和转发"></a>10. 未验证的重定向和转发</h2><p>应用程序经常将用户重定向到其他网页，或以类似的方式进行内部转发。当目标网页是通过一个未验证的参数来指定时，就容易被攻击者利用。攻击者通过诱使受害人去点击未经验证的重定向链接，从而利用不安全的转发绕过安全检测。攻击者通过重定向可以试图安装恶意软件或者诱使受害人泄露密码等敏感信息，通过转发可以绕过访问控制。</p><h4 id="防范：-7"><a href="#防范：-7" class="headerlink" title="防范："></a>防范：</h4><ul><li>避免使用重定向和转发</li><li>如果使用了重定向和转发，则不要在确定目标时涉及到用户参数。</li><li>如果无法避免使用目标参数，则应确保目标参数值对于当前用户是有效的并已授权。</li></ul><h4 id="操作步骤-9"><a href="#操作步骤-9" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>不希望存在漏洞吗？那就不要使用它。无论怎样，都不要使用重定向和转发。</li><li>如果需要使用重定向，尝试不要使用用户提供的参数（请求变量）来计算出目标。</li><li>如果需要使用参数，实现一个表，将其作为重定向的目录，使用 ID 代替 URL 作为用户应该提供的参数。</li><li>始终验证重定向和转发操作涉及到的输入。使用正则表达式或者白名单来检查提供的值是否有效。</li></ul><h4 id="工作原理-9"><a href="#工作原理-9" class="headerlink" title="工作原理"></a>工作原理</h4><p>重定向和转发是钓鱼者和其它社会工程师最喜欢用的工具，并且有时候我们对目标没有任何安全控制。所以，即使它不是我们的应用，它的安全问题也会影响我们的信誉。这就是最好不要使用它们的原因。</p><p>如果这种重定向的目标是已知站点，例如 Fackbook 或 Google，我们就可以在配置文件或数据表中建立目标目录，并且不需要使用客户端提供的参数来实现。</p><p>如果我们构建包含所有允许的重定向和转发 URL 的数据表，每个都带有 ID，我们可以将 ID 用于参数，而不是目标本身。这是一种白名单的形式，可以防止无效目标的插入。</p><p>最后同样是校验。我们始终要校验每个来自客户端的输入，这非常重要，因为我们不知道用户要输入什么。如果我们校验了重定向目标的正确性，除了恶意转发或重定向之外，我们还可以防止可能的 SQL 注入、XSS或者目录遍历。所以，它们都是相关的。</p>]]></content>
    
    
    <categories>
      
      <category>secuirty</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><ol><li><p>进程与线程的概念，区别</p><ul><li><p>进程：对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发，资源分配最小单位。</p></li><li><p>线程：进程的子任务，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p></li></ul><ul><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p></li><li><p>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（推存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p></li><li><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p></li><li><p>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p></li><li><p>通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p></li><li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p></li><li><p>进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p></li><li><p>进程适应于多核、多机分布；线程适用于多核。</p></li></ul></li><li><p>OS缺页置换算法</p><p> FIFO算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排序成队列，从队尾进入，从队首删除。</p><p> LRU算法：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p></li><li><p>死锁发生的条件/如何解决死锁</p><p> 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><ul><li><p>互斥条件：进程对所分配的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有资源的进程使用完成后释放该资源。</p></li><li><p>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</p></li><li><p>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。</p></li><li><p>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形锁。</p><p><b>解决方案：</b></p><p>资源一次性分配，从而剥夺请求和保持条件可剥夺资源：即当进程新的资源为获得满足时，释放已占有的资源，从而破坏不可剥夺的条件<br>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件。</p></li></ul></li><li><p>线程同步的几种方式：</p><ul><li><p>临界区：<br>  通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p></li><li><p>互斥量：<br>  采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p></li><li><p>信号量：<br>  为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p></li><li><p>事件（wait/notify）<br>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p></li></ul></li></ol><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><ol><li><p>互斥锁机制</p><ul><li><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p></li><li><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p><p><b>互斥锁和读写锁的区别</b></p></li><li><p>读写锁区分读者和写者，而互斥锁不区分</p></li><li><p>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间只允许一个写者，但是允许多个读者同时读该对象。</p></li></ul></li><li><p>Linux的四种锁机制：</p><p> 上面两种再加上：</p><ul><li><p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p></li><li><p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p></li></ul></li><li><p>软链接与硬链接区别</p><p> 为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p></li><li><p>大端小端区别以及如何判断</p><p> 大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p><pre><code class="cpp"> #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) {     union {         short s;         char c[sizeof(short)];     } un;     un.s = 0x0102;     if(sizeof(short)==2) {         if(un.c[0]==1 &amp;&amp; un.c[1] == 2)             printf(&quot;big-endian\n&quot;);         else if (un.c[0] == 2 &amp;&amp; un.c[1] == 1)             printf(&quot;little-endian\n&quot;);         else             printf(&quot;unknown\n&quot;);     } else         printf(&quot;sizeof(short)= %d\n&quot;,sizeof(short));     exit(0); }</code></pre></li><li><p>进程间通信的方式</p><ul><li><p>管道：</p><p>  管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><ul><li><p>普通管道PIPE：</p><p>  它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>  它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>  它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li><li><p>命名管道FIFO：</p><p>  FIFO可以在无关的进程之间交换数据</p><p>  FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li></ul></li><li><p>消息队列</p><p>  消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>  消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>  消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p></li><li><p>信号量semaphore</p><p>  信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于    存储进程间通信数据。</p><p>  信号量用于进程间同步，若要在进程间传递数" srcset="/img/loading.gif<img src="" alt="">据需要结合共享内存。</p><p>  信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。</p><p>  每次对信号量的PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>  支持信号量组。</p></li><li><p>事件（信号），Wait/Notify:</p><p>  通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p></li></ul></li></ol><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><ol><li><p>进程状态转换图</p><ul><li><p>进程的五种基本状态：<img src="/img/process_phrase.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等地I/O，等待设备，而暂时不能运行</li><li>终止状态：进程运行完毕</li></ul></li><li><p>交换技术：当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/O速度比处理剂速度慢得多，可能出现全部进程阻塞等待I/O。</p><p>  针以上问题，提出了两种解决方法：</p><ul><li><p>交换技术：换出一部分进程到外存，腾出内存空间</p></li><li><p>虚拟存储技术：每个进程只能装入一部分程序和数据</p><p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p><p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p></li></ul></li><li><p>活动阻塞，静止阻塞，活动就绪，静止就绪</p><ul><li><p>活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p></li><li><p>静止阻塞：进程在外存，同时被某种原因阻塞了。</p></li><li><p>活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p></li><li><p>静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p><p>从而出现了：</p><p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p><p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p><p>执行     ——  静止就绪         （时间片用完）</p></li></ul></li></ul></li><li><p>程序内存管理</p><p> 一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p><p> <img src="/img/memory_management.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p></li><li><p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p></li><li><p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p></li><li><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p></li><li><p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p></li><li><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p></li><li><p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p></li><li><p>可执行程序在运行时又多出两个区域：栈区和堆区。</p></li><li><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p></li><li><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p></li></ul></li><li><p>C++继承和虚函数</p><p> C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p><p> 动态多态实现有几个条件：</p><ul><li><p>虚函数</p></li><li><p>一个基类指针或引用指向派生类的对象</p><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p></li></ul></li></ol><ol start="4"><li><p>static修饰符和virtual修饰符</p><ul><li><p>static修饰符</p><ul><li><p>static修饰成员变量：</p><p>  对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p><p>  因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p></li><li><p>static修饰成员函数<br>  与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p><p>  Static修饰的成员函数，在代码区分配内存。</p></li></ul></li><li><p>virtual修饰符</p><p>  如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p><p>  如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。<br>  如果类中成员是virtual属性，会隐藏父类对应的属性。<br>  <img src="/img/virtual.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ol><ol start="5"><li><p>静态变量初始化</p><ul><li>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</li></ul></li><li><p>用户态和内核态区别</p><ul><li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</li></ul></li><li><p>内存溢出和内存泄露</p><ul><li><p>内存溢出</p><p>  指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p></li><li><p>内存溢出的原因：</p><p>  内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p><p>  集合类中有对对象的引用，使用完后未清空，使得不能回收</p><p>  代码中存在死循环或循环产生过多重复的对象实体</p><p>  使用的第三方软件中的BUG</p><p>  启动参数内存值设定的过小</p></li><li><p>内存泄露</p><p>  内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p></li><li><p>内存泄漏的分类：</p><ul><li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li><li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li></ul></li></ul></li><li><p>常用的线程模型</p></li></ol><ul><li><p>Future模型</p><p>  该模型通常在使用的时候需要结合Callable接口配合使用。</p><p>  Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p><p>  Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p></li><li><p>fork&amp;join模型</p><p>  该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p><p>  这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p></li><li><p>actor模型</p><p>  actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p></li><li><p>生产者消费者模型</p><p>  生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p></li><li><p>master-worker模型</p><p>  master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p></li></ul><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><ol><li><p>系统调用</p><ul><li><p>概念：</p><p>  在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p><p>  操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p><p>  应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p></li><li><p>系统调用举例：</p><p>  对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main(int argc, char *argv[]){  if (argc&lt;2)      return 0;  //用读写追加方式打开一个已经存在的文件  int fd = open(argv[1], O_RDWR | O_APPEND);  if (fd == -1)  {      printf(&quot;error is %s\n&quot;, strerror(errno));  }  else  {      //打印文件描述符号      printf(&quot;success fd = %d\n&quot;, fd);      char buf[100];      memset(buf, 0, sizeof(buf));      strcpy(buf, &quot;hello world\n&quot;);      write(fd, buf, strlen(buf));      close(fd);  }  return 0;}</code></pre><p>还有写数据write，创建进程fork，vfork等都是系统调用。</p></li></ul></li><li><p>用户态切换到内核态的3钟方法：</p><ul><li><p>系统调用</p><p>  这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p></li><li><p>异常</p><p>  当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p></li><li><p>外围设备的中断</p><p>  当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></li></ul></li><li><p>切换操作</p><p> 从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p><ul><li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li><li>使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li><li>将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li></ul></li><li><p>链接</p><p> 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ul><li><p>静态链接</p><p>  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p></li><li><p>动态链接</p><p>  动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p><p>  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p></li></ul></li><li><p>5种IO模型</p><ul><li>阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li>非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</li><li>信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li>IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li>异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul></li><li><p>多线程的同步， 锁的机制</p><ul><li>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</li></ul></li><li><p>线程池</p><ul><li>设置一个生产者消费者队列，作为临界资源</li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li><li>当任务队列为空的时候，所有线程阻塞</li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/17/hello-world/"/>
    <url>/2020/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
