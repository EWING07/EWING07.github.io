<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>libpcap文件格式分析</title>
    <link href="/2020/03/25/libpcap%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <url>/2020/03/25/libpcap%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本格式："><a href="#1-基本格式：" class="headerlink" title="1. 基本格式："></a>1. 基本格式：</h3><p>文件头 数据包头数据报</p>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h4 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h4><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。<br>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p><h4 id="数据库事务隔离"><a href="#数据库事务隔离" class="headerlink" title="数据库事务隔离"></a>数据库事务隔离</h4><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><h4 id="inner-join-amp-left-join-amp-right-join"><a href="#inner-join-amp-left-join-amp-right-join" class="headerlink" title="inner join &amp; left join &amp; right join"></a>inner join &amp; left join &amp; right join</h4><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录</p><p>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p><p>inner join(等值连接) 只返回两个表中联结字段相等的行</p><h4 id="数据库事务的四个特性"><a href="#数据库事务的四个特性" class="headerlink" title="数据库事务的四个特性"></a>数据库事务的四个特性</h4><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p><p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p><ol><li><p>原子性（Atomicity）</p><p> 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p> 数据库事务是一个整体，其中的SQL操作要么全部提交成功commit要么全部失败回滚rollback，不可分割；</p></li><li><p>一致性（Consistency）</p><p> 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p> 与原子性有联系。事务总是从一个一致状态转换到另一个一致状态；</p><p> 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性（Isolation）</p><p> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p> 事务之间彼此互不影响，一个事务在提交之前，对其他事务是不可见的。</p><p> 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p> 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p></li></ol><pre><code>不同的隔离级别：Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</code></pre><ol start="4"><li><p>持久性（Durability）</p><p> 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p> 一个事务一旦提交成功，他所做的修改就会永久性的存储在数据库中。</p><p> 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p></li></ol><h4 id="索引是什么，多加索引一定会好吗"><a href="#索引是什么，多加索引一定会好吗" class="headerlink" title="索引是什么，多加索引一定会好吗"></a>索引是什么，多加索引一定会好吗</h4><ol><li><p>索引</p><p> 数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p><p> DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><ul><li><p>优点：</p><p>  通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>  可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>  可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>  在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p></li><li><p>缺点：</p><p>  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>  索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>  当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></li></ul></li><li><p>添加索引原则</p><p> 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p> 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p> 定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p> 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></li><li><p>实现方法：一般分为B+树索引和哈希索引。</p><ul><li>B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。</li><li>哈希索引：通过对key进行hash(crc/MD5/sha1/sha256…)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1/256码都较长不太适合作为hash函数。默认无序。</li></ul></li><li><p>为什么有了B+树索引还要hash索引？</p><ul><li>B+树默认有序，hash默认无序，所以哈希索引无法用于排序；</li><li>哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);</li><li>哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；</li><li>底层实现结构不同：B+树是非线性结构，hash桶是线性结构。</li><li>对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。</li></ul></li></ol><h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p><p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p><p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><ol><li>在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；</li><li>多次查询同样的数据，可以考虑缓存该组数据；</li><li>审视select * form tables, 你需要所有列数据吗？</li><li>切分查询（大查询切分成为小查询，避免一次性锁住大量数据）</li><li>分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）</li><li>尽量先做单表查询；</li></ol><h4 id="MySQL查询步骤"><a href="#MySQL查询步骤" class="headerlink" title="MySQL查询步骤"></a>MySQL查询步骤</h4><ol><li>客户端发送查询到服务器；</li><li>服务器检查查询缓存query ***（大小写敏感的哈希查找，常数时间）。如果命中，返回缓存中的结果，否则下一步；</li><li>解析语句，生成执行计划；（SQL解析，预处理，优化器生成执行计划）；</li><li>根据执行计划，根据存储引擎的不同调用API，执行查询（一棵指令树）；</li><li>结果返回客户端。</li></ol><h4 id="MySQL的MVCC机制"><a href="#MySQL的MVCC机制" class="headerlink" title="MySQL的MVCC机制"></a>MySQL的MVCC机制</h4><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p><h4 id="MySQL引擎和区别"><a href="#MySQL引擎和区别" class="headerlink" title="MySQL引擎和区别"></a>MySQL引擎和区别</h4><ol><li><p>MySQL引擎</p><p> MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p> 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p><p> MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p><p> 但是最常用的是InnoDB和Mylsam。</p></li><li><p>InnoDB</p><p> InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p><p> Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><p> 适用场景：</p><p> 经常更新的表，适合处理多重并发的更新请求。</p><p> 支持事务。</p><p> 可以从灾难中恢复（通过bin-log日志等）。</p><p> 外键约束。只有他支持外键。</p><p> 支持自动增加列属性auto_increment。</p><p> 索引结构：</p><p> InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p> InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p></li><li><p>Mylsam</p><p> MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p><p> 适用场景：</p><p> 不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p><p> 不支持外键的表设计。</p><p> 查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p><p> 整天对表进行加锁的场景。</p><p> MyISAM极度强调快速读取操作。</p><p> MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p><p> 缺点：就是不能在表损坏后主动恢复数据。</p><p> 索引结构：</p><p> MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p></li><li><p>区别</p><p> 1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p><p> 2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p><p> 3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p><p> 4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p><p> MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p><p> InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p><p> 5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p><p> MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p><p> InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><p> 6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的</p><p> <strong>精辟</strong>：在Mysql数据库中，常用的引擎为Innodb和MyIASM,其中Innodb是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事物的支持，实现了SQL标准的四种隔离级别，即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。而MyIASM引擎是Mysql默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当进行select count(*)form table时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，并且不需要事务支持时，可以优先选择MyIASM</p></li></ol><h4 id="mongodb和redis的区别"><a href="#mongodb和redis的区别" class="headerlink" title="mongodb和redis的区别"></a>mongodb和redis的区别</h4><p>内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</p><p>支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list等。</p><p>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</p><h4 id="Redis的定时机制"><a href="#Redis的定时机制" class="headerlink" title="Redis的定时机制"></a>Redis的定时机制</h4><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。</p><p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件</p><h4 id="Redis是单线程的，但是为什么这么高效呢"><a href="#Redis是单线程的，但是为什么这么高效呢" class="headerlink" title="Redis是单线程的，但是为什么这么高效呢?"></a>Redis是单线程的，但是为什么这么高效呢?</h4><p>虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h4 id="请问Redis的数据类型有哪些，底层怎么实现？"><a href="#请问Redis的数据类型有哪些，底层怎么实现？" class="headerlink" title="请问Redis的数据类型有哪些，底层怎么实现？"></a>请问Redis的数据类型有哪些，底层怎么实现？</h4><p>1）字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)<br>2）列表：压缩列表、双端链表</p><p>3）哈希：压缩列表、字典</p><p>4）集合：整数集合、字典</p><p>5）有序集合：压缩列表、跳跃表和字典</p><h4 id="Redis和memcahed区别"><a href="#Redis和memcahed区别" class="headerlink" title="Redis和memcahed区别"></a>Redis和memcahed区别</h4><p>1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象<br>2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)</p><p>3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。</p><p>4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</p><p>5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作</p><p>6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="TCP保证可靠性"><a href="#TCP保证可靠性" class="headerlink" title="TCP保证可靠性"></a>TCP保证可靠性</h4><ol><li><p>序列号、确认应答、超时重传</p><p> 数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p></li><li><p>窗口控制与高速重发控制/快速重传（重复确认应答）</p><p> TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p><p> 使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p></li><li><p>拥塞控制</p><p> 如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p><p> 慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p><p> 拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p><p> 将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p><p> 快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p><p> 然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p><p> 这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p><p> 采用慢开始和拥塞避免算法的时候</p><ul><li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p></li><li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p><p>采用快恢复和快重传算法的时候</p></li><li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p></li><li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p></li></ul></li></ol><h4 id="TCP建立连接和断开连接的过程："><a href="#TCP建立连接和断开连接的过程：" class="headerlink" title="TCP建立连接和断开连接的过程："></a>TCP建立连接和断开连接的过程：</h4><p><img src="/img/TCP.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>三次握手：</p><ol><li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p></li><li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p></li><li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p>三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p></li></ol></li><li><p>四次挥手：</p><p>  由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><ol><li><p>数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p></li><li><p>服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p></li><li><p>当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p></li><li><p>客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p><p>四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p></li></ol></li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ol><li><p>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p></li><li><p>HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p></li><li><p>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p></li><li><p>HTTP协议端口是80，HTTPS协议端口是443</p></li></ol><h4 id="HTTPS优缺点"><a href="#HTTPS优缺点" class="headerlink" title="HTTPS优缺点"></a>HTTPS优缺点</h4><ul><li><p>优点：</p><p>  HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p><p>  HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p></li><li><p>缺点：</p><p>  HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p><p>  HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p></li></ul><h4 id="IP地址和MAC地址的作用"><a href="#IP地址和MAC地址的作用" class="headerlink" title="IP地址和MAC地址的作用"></a>IP地址和MAC地址的作用</h4><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><h4 id="OSI七层模型和TCP-IP四层模型，每层列举两个协议"><a href="#OSI七层模型和TCP-IP四层模型，每层列举两个协议" class="headerlink" title="OSI七层模型和TCP/IP四层模型，每层列举两个协议"></a>OSI七层模型和TCP/IP四层模型，每层列举两个协议</h4><ol><li>OSI七层模型及其包含的协议如下：</li></ol><ul><li><p>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</p></li><li><p>数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</p></li><li><p>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</p></li></ul><ul><li><p>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</p></li><li><p>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p></li><li><p>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p></li><li><p>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p></li></ul><ol start="2"><li><p>TCP/IP 4层模型包括：</p><p> 网络接口层：MAC VLAN</p><p> 网络层:IP ARP ICMP</p><p> 传输层:TCP UDP</p><p> 应用层:HTTP DNS SMTP</p></li></ol><h4 id="TCP握手为什么两次不可以，为什么不用四次"><a href="#TCP握手为什么两次不可以，为什么不用四次" class="headerlink" title="TCP握手为什么两次不可以，为什么不用四次"></a>TCP握手为什么两次不可以，为什么不用四次</h4><ul><li><p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p></li><li><p>四次不可以：</p><p>  本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：</p><ol><li><p>客户端发送syn0给服务器</p></li><li><p>服务器收到syn0，回复ack(syn0+1)</p></li><li><p>服务器发送syn1</p></li><li><p>客户端收到syn1，回复ack(syn1+1)</p><p>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p></li></ol></li></ul><h4 id="TCP和UDP的区别和各自适用的场景"><a href="#TCP和UDP的区别和各自适用的场景" class="headerlink" title="TCP和UDP的区别和各自适用的场景"></a>TCP和UDP的区别和各自适用的场景</h4><ol><li><p>TCP和UDP区别</p><p> 1） 连接</p><p> TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</p><p> UDP无连接。</p><p> 2） 服务对象</p><p> TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p><p> UDP支持一对一，一对多，多对一，多对多的交互通信。</p><p> 3） 可靠性</p><p> TCP是可靠交付：无差错，不丢失，不重复，按序到达。</p><p> UDP是尽最大努力交付，不保证可靠交付。</p><p> 4）拥塞控制，流量控制</p><p> TCP有拥塞控制和流量控制保证数据传输的安全性。</p><p> UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p><p> 5） 报文长度</p><p> TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p><p> UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p><p> 6)   首部开销</p><p> TCP首部开销大，首部20个字节。</p><p> UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p></li><li><p>TCP和UDP适用场景</p><p> 从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p><p> 若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p></li></ol><h4 id="HTTP请求-响应的步骤如下："><a href="#HTTP请求-响应的步骤如下：" class="headerlink" title="HTTP请求/响应的步骤如下："></a>HTTP请求/响应的步骤如下：</h4><ol><li>客户端连接到Web服务器</li></ol><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com。" target="_blank" rel="noopener">http://www.baidu.com。</a></p><ol start="2"><li>发送HTTP请求</li></ol><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><ol start="3"><li>服务器接受请求并返回HTTP响应</li></ol><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><ol start="4"><li>释放连接TCP连接</li></ol><p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keep alive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><ol start="5"><li>客户端浏览器解析HTML内容</li></ol><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><ol start="6"><li><p>举例：<br> 在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ul><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p></li><li><p>浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p></li><li><p>释放 TCP连接；</p></li><li><p>浏览器将该 html 文本并显示内容；</p></li></ul></li></ol><h4 id="socket编程中服务器端和客户端主要用到哪些函数"><a href="#socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="socket编程中服务器端和客户端主要用到哪些函数"></a>socket编程中服务器端和客户端主要用到哪些函数</h4><ul><li><p>基于TCP的socket</p><ol><li>服务器端程序<ul><li>1 创建一个socket，用函数socket()</li><li>2 绑定IP地址、端口等信息到socket上，用函数bind()</li><li>3 设置允许的最大连接数，用函数listen()</li><li>4 接收客户端上来的连接，用函数accept()</li><li>5 收发数据，用函数send()和recv()，或者read()和write()</li><li>6 关闭网络连接</li></ul></li><li>客户端程序<ul><li>1 创建一个socket，用函数socket()</li><li>2 设置要连接的对方的IP地址和端口等属性</li><li>3 连接服务器，用函数connect()</li><li>4 收发数据，用函数send()和recv()，或read()和write()</li><li>5 关闭网络连接<br><img src="/img/TCP_socket.png" srcset="/img/loading.gif" alt=""></li></ul></li></ol></li><li><p>基于UDP的socket</p><ol><li>服务器端程序<ul><li>1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li><li>2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li><li>3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li><li>4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li><li>5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li><li>6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li></ul></li><li>客户端流程<ul><li>1建立套接字文件描述符，socket()。</li><li>2设置服务器地址和端口，struct sockaddr。</li><li>3向服务器发送数据，sendto()。</li><li>4接收服务器的数据，recvfrom()。</li><li>5关闭套接字，close()。<br><img src="/img/UDP_socket.png" srcset="/img/loading.gif" alt=""></li></ul></li></ol></li></ul><h4 id="阻塞，非阻塞，同步，异步"><a href="#阻塞，非阻塞，同步，异步" class="headerlink" title="阻塞，非阻塞，同步，异步"></a>阻塞，非阻塞，同步，异步</h4><p>阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p><p>同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步</p><h4 id="TCP-IP数据链路层的交互过程"><a href="#TCP-IP数据链路层的交互过程" class="headerlink" title="TCP/IP数据链路层的交互过程"></a>TCP/IP数据链路层的交互过程</h4><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP TPO10 漏洞和防范</title>
    <link href="/2020/03/18/OWASP-TPO10-%E6%BC%8F%E6%B4%9E%E5%92%8C%E9%98%B2%E8%8C%83/"/>
    <url>/2020/03/18/OWASP-TPO10-%E6%BC%8F%E6%B4%9E%E5%92%8C%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-注入-Injection"><a href="#1-注入-Injection" class="headerlink" title="1. 注入 Injection"></a>1. 注入 Injection</h2><p>Web安全头号大敌。注入攻击漏洞往往是应用程序缺少对输入进行安全性检查所引起的。攻击者把一些包含攻击代码当做命令或者查询语句发送给解释器，这些恶意数据可以欺骗解释器，从而执行计划外的命令或者未授权访问数据。注入漏洞通常能SQL查询、LDAP查询、OS命令、程序参数等中出现。</p><h4 id="防范方法："><a href="#防范方法：" class="headerlink" title="防范方法："></a>防范方法：</h4><ul><li>使用安全的API，避免使用解释器或提供参数化的接口（prepared statements， or stored procedures)</li><li>使用白名单来规范化的输入验证方法</li><li>对输入的特殊字符进行Escape转义处理</li><li>权限最小化，减轻被注入的影响</li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>为了防止注入攻击，首先需要合理校验输入。在服务端，这可以由编写我们自己的校验流程来实现，但是最佳选择是使用语言自己的校验流程，因为它们更加广泛使用并测试过。一个极好的激励就是 PHP 中的<code>filter_var</code>，或者 ASP.NET 中的 校验助手。例如，PHP 中的邮箱校验类似于</p><pre><code class="php">  function isValidEmail($email){      return filter_var($email, FILTER_VALIDATE_EMAIL);  }</code></pre></li><li><p>在客户端，检验可以由创建 JavaScript 校验函数来完成，使用正则表达式。例如，邮箱检验流程是：</p><pre><code class="JavaScript">  function isValidEmail (input) {       var result=false;       var email_regex = /^[a-zA-Z0-9._-]+@([a-zA-Z0-9.-]+\.)+[azA-Z0-9.-]{2,4}$/;       if ( email_regex.test(input) ) {           result = true;       }       return result;   }</code></pre></li><li><p>对于 SQL 注入，避免拼接输入值为查询十分关键。反之，使用参数化查询。</p><p>  如：Java：</p><pre><code>  String custname =  request.getParameter(&quot;customerName&quot;);   String query = &quot;SELECT account_balance FROM user_data WHERE user_ name =? &quot;;   PreparedStatement pstmt = connection.prepareStatement( query );   pstmt.setString( 1, custname);   ResultSet results = pstmt.executeQuery( );</code></pre></li><li><p>考虑注入出现的时机，对减少可能的损失总量也有帮助。所以，使用低权限的系统用户来运行数据库和 Web 服务器。</p></li><li><p>确保输入用于连接数据库服务器的用户不是数据库管理员。</p></li><li><p>禁用甚至删除允许攻击者执行系统命令或提权的储存过程，例如 MSSQL 服务器中的<code>xp_cmdshell</code>。</p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>预防任何类型代码注入攻击的主要部分永远是合理的输入校验，位于服务端也位于客户端。</p><p>对于 SQL 注入，始终使用参数化或者预编译查询。而不是拼接 SQL 语句和输入。参数化查询将函数参数插入到 SQL 语句特定的位置，消除了程序员通过拼接构造查询的需求。</p><p>这个秘籍中，我们使用了语言内建的校验函数，但是如果你需要校验一些特殊类型的参数，你可以通过使用正则表达式创建自己的版本。</p><p>除了执行正确校验，我们也需要在一些人蓄意注入一些代码的情况下，降低沦陷的影响。这可以通过在操作系统的上下文中为 Web 服务器合理配置用户权限，以及在数据库服务器上下文中配置数据库和 OS 来实现。</p><h2 id="2-失效的身份认证和会话管理-Broken-Authentication-and-Session-Management"><a href="#2-失效的身份认证和会话管理-Broken-Authentication-and-Session-Management" class="headerlink" title="2. 失效的身份认证和会话管理  Broken Authentication and Session Management"></a>2. 失效的身份认证和会话管理  Broken Authentication and Session Management</h2><p>与认证和会话管理相关的应用程序功能往往得不到正确管理，这就导致攻击者破话密码、密匙、会话令牌或利用实施漏洞冒充其他用户身份</p><h4 id="防范方法：-1"><a href="#防范方法：-1" class="headerlink" title="防范方法："></a>防范方法：</h4><p>使用强大的认证和会话管理控制-OWASP的应用安全验证标准</p><ul><li>使用简单集中标准化的认证方式</li><li>确保SSL在任何时候都会保护会话</li><li>使用会话管理功能</li></ul><p>会话管理：当用户不操作时，系统必须自动终止超时会话，必须有时间限制；必须提供退出功能，允许用户强制退出会话；会话标识足够随机，防止攻击者猜测到标识；用户登录后必须分配新的会话标识，不使用用户未登录前所使用的标识，防止会话攻击</p><h4 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>如果应用中存在只能由授权用户查看的页面、表单或者任何信息片段，确保在展示它们之前存在合理的身份验证。</li><li>确保用户名、ID、密码和所有其它身份验证数据是大小写敏感的，并且对每个用户唯一。</li><li>建立强密码策略，强迫用户创建至少满足下列条件的密码：<ul><li>对于 8 个字符，推荐 10 个。</li><li>使用大写和小写字母。</li><li>至少使用一个数字。</li><li>至少使用一个特殊字符（空格、!、&amp;、#、%，以及其它）。</li><li>禁止用户名、站点名称、公司名称或者它们的变体（大小写转换、l33t、它们的片段）用于密码。</li><li>禁止使用“常见密码”列表中的密码：<a href="https://www.teamsid.com/worst-passwords-2015/" target="_blank" rel="noopener">https://www.teamsid.com/worst-passwords-2015/ </a></li><li>永远不要显示用户是否存在或者信息格式是否正确的错误信息。对不正确的登录请求、不存在的用户、名称或密码不匹配模式、以及所有可能的登录错误使用相同的泛化信息。这种信息类似于<ul><li>登录数据不正确。</li><li>用户名或密码无效。</li><li>访问禁止。</li></ul></li></ul></li><li>密码不能以纯文本格式储存在数据库中。使用强哈希算法，例如 SHA-2、scrypt、或者 bcrypt，它们特别为难以使用 GPU 破解而设计。</li><li>在对比用户输入和密码时，计算输入的哈希之后比较哈希之后的字符串。永远不要解密密码来使用纯文本用户输入来比较。</li><li>避免基本的 HTML 身份验证。</li><li>可能的话，使用多因素验证（MFA），这意味着使用不止一个身份验证因素来登录：<ul><li>一些你知道的（账户信息或密码）</li><li>一些你拥有的（标识或手机号）</li><li>一些你的特征（生物计量）</li></ul></li><li>如果可能的话，实现证书、预共享密钥、或其它无需密码的身份校验协议（OAuth2、OpenID、SAML、或者 FIDO）。</li><li>对于会话管理，推荐使用语言内建的会话管理系统，Java、ASP.NET和 PHP。它们并不完美，但是能够确保提供设计良好和广泛测试的机制，而且比起开发团队在时间紧迫情况下的自制版本，它们更易于实现。</li><li>始终为登录和登录后的页面使用 HTTPS – 显然，要防止只接受 SSL 和 TLS v1.1 连接。</li><li>为了确保 HTTPS 能够生效，可以使用 HSTS。它是由 Web 应用指定的双向选择的特性。通过 Strict-Transport-Security 协议头，它在 http://<br>存在于 URL 的情况下会重定向到安全的选项，并防止“无效证书”信息的覆写。例如使用 Burp Suite 的时候会出现的情况。更多信息请见：<a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">https://www.owasp.org/index.php/HTTP_Strict_Transport_Security</a></li><li>设置 HTTPOnly 和安全的 Cookie 属性。</li><li>设置最少但实际的会话过期时间。确保正常用户离开之后，攻击者不能复用会话，并且用户能够执行应用打算执行的操作。</li></ul><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>身份校验机制通常在 Web 应用中简化为用户名/密码登录页面。虽然并不是最安全的选择，但它对于用户和开发者最简单，以及当密码被盗取时，最重要的层面就是它们的强度。</p><p>我们可以从这本书看到，密码强度由破解难度决定，通过爆破、字典或猜测。这个秘籍的第一个提示是为了使密码更难以通过建立最小长度的混合字符集来破解，难以通过排除更直觉的方案（用户名、常见密码、公司名称）来猜测，并且通过使用强哈希或加密储存，难以在泄露之后破解。</p><p>对于会话管理来说，过期时间、唯一性和会话 ID 的强度（已经在语言内建机制中实现），以及 Cookie 设置中的安全都是关键的考虑因素。</p><p>谈论身份校验安全的最重要的层面是，如果消息可以通过中间人攻击拦截或者服务，没有任何安全配置、控制或强密码是足够安全的。所以，合理配置的加密通信频道的使用，例如 TLS，对保护我们的用户身份数据来说极其重要。</p><h2 id="3-跨站脚本-XSS"><a href="#3-跨站脚本-XSS" class="headerlink" title="3. 跨站脚本-XSS"></a>3. 跨站脚本-XSS</h2><p>XSS的出现时间跟SQL差不多，是最普遍的web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证或转译，就会导致跨站脚本漏洞。XSS允许攻击者在受害者的浏览器中执行脚本，这些脚本可以劫持用户会话，破坏网站，或将用户重定向到恶意站点。</p><h4 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h4><ul><li>对所有不可信的输入数据进行恰当的转义escape</li><li>使用白名单的具有恰当的规范化解码功能的输入验证方法</li><li>使用内容安全策略（CSP）来抵御整个站点的攻击</li></ul><h4 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>应用存在 XSS 漏洞的第一个标志是，页面准确反映了用户提供的输入。所以，尝试不要使用用户提供的信息来构建输出文本。</p></li><li><p>当你需要将用户提供的信息放在输出页面上时，校验这些数据来防止任何类型代码的插入。我们已经在 A1 中看到如何实现它。</p></li><li><p>出于一些原因，如果用户被允许输入特殊字符或者代码段，在它插入到输出之前，过滤或合理编码文本。</p></li><li><p>对于过滤，在 PHP 中，可以使用filter_var。例如，如果你想让字符串为邮件地址：</p><pre><code class="php">  $email = &quot;john(.doe)@exa//mple.com&quot;;   $email = filter_var($email, FILTER_SANITIZE_EMAIL);   echo $email;</code></pre></li><li><p>在 .NET 中，对于 4.5 及更高版本，System.Web.Security.AntiXss<br>命名空间提供了必要的工具。对于 .NET 框架 4 及之前的版本，你可以使用 Web 保护库：<a href="http://wpl.codeplex.com/" target="_blank" rel="noopener">http://wpl.codeplex.com/</a></p></li><li><p>同样，为了防止储存型 XSS，在储存进数据库或从数据库获取之前，编码或过滤每个信息片段。</p></li><li><p>不要忽略头部、标题、CSS和页面的脚本区域，因为它们也可以被利用。</p></li></ul><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><p>除了合理的输入校验，以及不要将用户输入用作输出信息，过滤和编码也是防止 XSS 的关键层面。</p><p>过滤意味着从字符串移除不允许的字符。这在输入字符串中存在特殊字符时很实用。</p><p>编码将特殊字符转换为 HTML 代码表示。例如，<code>&amp;</code>变为<code>&amp;amp</code>、<code>&lt;</code>变为<code>&amp;lt</code>。一些应用允许在输入字符串中使用特殊字符，对它们来说过滤不是个选择。所以应该在将输入插入页面，或者储存进数据库之前编码输入。</p><h2 id="4-不安全的直接对象引用-Insecurity-Direct-Object-Reference"><a href="#4-不安全的直接对象引用-Insecurity-Direct-Object-Reference" class="headerlink" title="4. 不安全的直接对象引用 Insecurity Direct Object Reference"></a>4. 不安全的直接对象引用 Insecurity Direct Object Reference</h2><p>当开发人员公开对内部实现对象（如文件、目录或数据库键）的引用时，就会出现直接对象引用。如果没有访问控制检查或其他保护，攻击者可以操纵这些引用来访问未经授权的数据</p><h4 id="防范：-1"><a href="#防范：-1" class="headerlink" title="防范："></a>防范：</h4><ul><li>使用基于用户或会话的间接对象访问，防止攻击者直接攻击未授权资源。</li><li>访问检查：对任何来自不受信源所使用直接对象引用都进行访问控制检测，确保用户对要求的对象有访问权限。</li></ul><h4 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>使用非直接引用优于直接引用。例如，不要通过参数中的名称来引用页面（<code>URL?page=&quot;restricted_page&quot;</code>），而是要创建索引，并在内部处理它（<code>URL?page=2</code>）。</li><li>将非直接引用映射到用户（会话）层面，于是用户仅仅能够访问授权的对象，即使它们修改了下标。</li><li>在传递相应对象之前校验引用，如果请求的用户没有权限来访问，展示通用错误页面。</li><li>输入校验也是很重要的，尤其是目录遍历和文件包含的情况下。</li><li>永远不要采取“隐藏式安全”的策略。如果有些文件包含受限的信息，即使它没有引用，有些人也会把它翻出来。</li></ul><h4 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h4><p>不安全对象的直接引用在 Web 应用中的表现形式有所不同，从目录遍历到敏感的 PDF 文档的引用。但是它们的大多数都依赖于一个假设，即用户永远不会找到方法来访问不能显式访问的东西。</p><p>为了防止这种漏洞，需要在设计和开发期间执行一些积极操作。设计可靠授权机制，来验证尝试访问一些信息的用户的关键是，是否用户真正允许访问它。</p><p>将引用对象映射为下标来避免对象名称直接用于参数值（就像 LFI 中的那样）是第一步。攻击者也可以修改下标，这很正常，就像对对象名称所做的那样。但是数据库中存在下标-对象的表的话，添加字段来规定访问所需的权限级别，比起没有任何表并且直接通过名称来访问资源，要容易得多。</p><p>之前说过，下标的表可能包含访问对象所需的权限级别，更加严格的话还有拥有者的 ID。所以，它只能够在请求用户是拥有者的情况下访问。</p><p>最后，输入校验必须存在于 Web 应用安全的每个层面。</p><h2 id="5-安全配置错误-Security-Misconfiguration"><a href="#5-安全配置错误-Security-Misconfiguration" class="headerlink" title="5.安全配置错误 Security Misconfiguration"></a>5.安全配置错误 Security Misconfiguration</h2><p>良好的安全性需要为应用程序、框架、应用服务器、web服务器、数据库服务器和平台定义和部署安全配置。默认值通常是不安全的。另外，软件应该保持更新。攻击者通过访问默认账户、未使用的网页、未安装补丁的漏洞、未被保护的文件和目录，以获得对系统未授权的访问。</p><h4 id="防范：-2"><a href="#防范：-2" class="headerlink" title="防范："></a>防范：</h4><ul><li>及时了解并部署每个环节的软件更新和补丁信息，包括所有的代码库。（自动化安装部署）</li><li>统一出错处理机制，错误处理会向用户显示堆栈跟踪或其他过于丰富的错误信息。</li><li>使用提供有效分离和安全性强大的应用程序架构</li></ul><h4 id="操作步骤-4"><a href="#操作步骤-4" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>可能的话，删除所有管理员应用，例如 Joomla 的 admin，WordPress 的 admin，PhpMyAdmin，或者 Tomcat Manager。如果不能这样，使它们只能从本地网络访问，例如，在 Apache 服务器中禁止来自外部网络的 PhpMyAdmin 访问，修改httd.conf文件（或者相应的站点配置文件）</li><li>修改所有 CMS、应用、数据库、服务器和框架的所有管理员密码，使其强度足够。</li><li>禁用所有不必要或未使用的服务器和应用特性。从日常或每周来看，新的漏洞都出现在 CMS 的可选模块和插件中。如果你的应用不需要它们，就不要激活它们。</li><li>始终执行最新的安全补丁和更新。在生成环境，建立测试环境来预防使站点不工作的缺陷十分重要，因为新版本存在一些兼容性及其它问题。</li><li>建立不会泄露跟踪信息、软件版本、程序组件名称，或任何其它调试信息的自定义的错误页面。如果开发者需要跟踪错误记录或者一些一些标识符对于技术支持非常必要，创建带有简单 ID 和错误描述的索引，并只展示 ID 给用户。所以当错误报告给相关人士的时候，它们会检查下标并且知道发生了什么错误。</li><li>采取“最小权限原则”。每个用户在每个层面（操作系统、数据库、或应用）上都应该只能够严格访问正确操作所需的信息。</li><li>使用上一个要点来考虑账户，构建安全配置的原则，并且将其应用到每个新的实现、更新或发布以及当前系统中。</li><li>强制定期的安全测试或审计，来帮助检测错误配置或遗漏的补丁。</li></ul><h4 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h4><p>谈论安全和配置问题时，“细节决定成败”十分恰当。web 服务器、数据库服务器、CMS、或者应用配置应该在完全可用和实用、以及保护用户和拥有者之间取得平衡。</p><p>Web 应用的一个常见错误配置就是一些 Web 管理站点对整个互联网都可见。这看起来并不是个大问题，但是我们应该知道，管理员登录页面更容易吸引攻击者，因为它可以用于获得高级权限等级，并且任何 CMS、数据或者站点管理工具都存在已知的常用默认密码列表。所以，我们强烈推荐不要把这些管理站点暴露给外部，并且尽可能移除它们。</p><p>此外，强密码的使用，以及修改默认密码（即使它们是强密码），在发布应用到公司内部网络，以及互联网的时候需要强制执行。当今，当我们将服务器开放给外部的时候，它收到的第一个流量就是端口扫描，登录页面请求，以及登录尝试，甚至在第一个用户知道该应用之前。</p><p>自定义错误页面的使用有助于安全准备，因为 Web 服务器和应用中的默认的错误信息展示太多的信息（从攻击者角度），它们关于错误、所使用的编程语言、栈回溯、所使用的数据库、操作系统以及其它。这些信息不应该暴露，因为它会帮助我们理解应用如何构建，并且提供所使用软件的版本和名称。攻击者通过这些信息就可以搜索已知漏洞，并构造更加有效的攻击过程。</p><p>一旦我们的服务器上的部署应用和所有服务都正确配置，我们就可以制订安全原则并且将其应用于所有要配置的新服务器或者已更新的服务器，或者当前带有合理规划的生产服务器。</p><p>这个配置原则需要持续测试，以便改进它以及持续保护新发现的漏洞。</p><h2 id="6-敏感信息泄露-Sensitive-Data-Exposure"><a href="#6-敏感信息泄露-Sensitive-Data-Exposure" class="headerlink" title="6. 敏感信息泄露 Sensitive Data Exposure"></a>6. 敏感信息泄露 Sensitive Data Exposure</h2><p>保护与加密敏感数据已经成为网络应用的最重要的组成部分。最常见的漏洞是应该进行加密的数据没有进行加密。使用加密的情况下常见问题是不安全的密钥和使用弱算法加密。</p><h4 id="防范：-3"><a href="#防范：-3" class="headerlink" title="防范："></a>防范：</h4><ul><li>加密存储和传输所有的敏感数据</li><li>确保使用合适强大的标准算法和密钥，并且密钥管理到位</li><li>确保使用密码专用算法存储密码</li><li>及时清除没有必要存放的重要的/敏感数据</li><li>禁用自动收集敏感数据，禁用包含敏感数据的页面缓存</li><li>加密方法：采用非对称加密算法管理对加密算法密钥，用对称加密算法加密数据</li></ul><h4 id="操作步骤-5"><a href="#操作步骤-5" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li><p>如果你使用的敏感数据可以在使用之后删除，那么删除它。最好每次使用信用卡的时候询问用户，避免被盗取。</p></li><li><p>在处理支付的时候，始终使用支付网关，而不是在你的服务器中储存数据。</p></li><li><p>如果我们需要储存敏感数据，我们要采取的第一个保护就是使用强密码算法和相应的强密钥来加密。推荐 Twofish、AES、RSA 和三重 DES。</p></li><li><p>密码储存在数据库的时候，应该以单项哈希函数的哈希形式存储，例如，bcypt、scrypt 或 SHA-2。</p></li><li><p>确保所有敏感文档只能被授权用户访问。不要在 Web 服务器的文档根目录储存它们，而是在外部目录储存，并通过程序来访问。如果出于某种原因必须在服务器的文档根目录储存敏感文件，使用<code>.htaccess</code>文件来防止直接访问：</p><pre><code>  Order deny, allow  Deny from all</code></pre></li><li><p>禁用包含敏感数据的页面缓存。例如，在 Apache 中我们可以禁用 PDF 和 PNG 的缓存，通过<code>httpd.conf</code>中的下列设置：</p><pre><code>  &lt;FilesMatch &quot;\.(pdf|png)&gt;   FileETag None   Header unset ETag   Header set Cache-Control &quot;max-age=0, no-cache, no-store, mustrevalidate&quot;   Header set Pragma &quot;no-cache&quot;   Header set Expires &quot;Wed, 11 Jan 1984 05:00:00 GMT&quot;   &lt;/FilesMatch&gt;</code></pre></li><li><p>如果你允许文件上传，始终使用安全的通信频道来传输敏感数据，也就是带有 TLS 的 HTTPS，或者 FTPS（SSH 上的 FTP）。</p></li></ul><h4 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h4><p>对于保护敏感数据，我们需要最小化数据泄露或交易的风险。这就是正确加密储存敏感数据，以及保护加密密钥是所做的第一件事情的原因。如果可能不需要储存这类数据，这只是个理想选择。</p><p>密码应该使用单向哈希算法，在将它们储存到数据之前计算哈希。所以，即使它们被盗取，攻击者也不能立即使用它们，并且如果密码强度足够，哈希也是足够强的算法，它就不会在短时间内被破解。</p><p>如果我们在 Apache 服务器的文档根目录（<code>/var/ www/html/</code>）储存敏感文档或数据，我们就通过 URL 将这些信息暴露用于下载。所以，最好将它储存到别的地方，并编写特殊的服务端代码来在必要时获取它们，并带有预先的授权检查。</p><p>此外，例如 Archive.org、WayBackMachine 或者 Google 缓存页面，可能在缓存含有敏感信息的文件时，以及我们没能在应用的上一个版本有效保护它们时产生安全问题。所以，不允许缓存此类文档非常重要。</p><h2 id="7-缺少功能级访问控制"><a href="#7-缺少功能级访问控制" class="headerlink" title="7. 缺少功能级访问控制"></a>7. 缺少功能级访问控制</h2><p>大多数web应用程序在实现UI中可见的功能之前，都要验证功能级别的访问权限。但是，当访问每个函数时，应用程序需要在服务器上执行相同的访问控制检查。如果请求没有得到验证，攻击者将能够伪造请求，以便在没有适当授权的情况下访问功能。</p><h4 id="防范：-4"><a href="#防范：-4" class="headerlink" title="防范："></a>防范：</h4><ul><li>检查管理权限的过程并确保能够容易进行升级和审计，切忌硬编码。</li><li>默认缺省情况下，应该拒绝所有访问的执行权限</li><li>对于每个功能的访问，需要明确的角色授权。检查每个功能分配的权限合理有效</li></ul><h4 id="操作步骤-6"><a href="#操作步骤-6" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>确保每一步都正确检查了工作流的权限。</li><li>禁止所有默认访问，之后在显示的授权校验之后允许访问。</li><li>用户、角色和授权应该在灵活的媒介中储存，例如数据库或者配置文件，不要硬编码它们。</li><li>同样，“隐藏式安全”不是很好的策略。</li></ul><h4 id="工作原理-6"><a href="#工作原理-6" class="headerlink" title="工作原理"></a>工作原理</h4><p>开发者只在工作流的开始检查授权，并假设下面的步骤都已经对用户授权，这是常见的现象。攻击者可能会尝试调用某个功能，它是工作流的中间步骤，并由于控制缺失而能够访问它。</p><p>对于权限，默认禁止所有用户是个最佳实践。如果我们不知道一些用户是否有权访问一些功能，那么它们就不应该执行。将你的权限表转化为授权表。如果某些用户在某些功能上没有显式的授权，则禁止它们的访问。</p><p>在为你的应用功能构建或实现访问控制机制的时候，将所有授权储存在数据库中，或者在配置文件中（数据库是最好的选项）。如果用户角色和权限被硬编码，它们就会难以维护、修改或更新。</p><h2 id="8-跨站请求伪造CSRF"><a href="#8-跨站请求伪造CSRF" class="headerlink" title="8. 跨站请求伪造CSRF"></a>8. 跨站请求伪造CSRF</h2><p>利用了网站允许攻击者预测特定操作的所有细节这一特点。由于浏览器自动发送会话cookie等认证凭证，导致攻击者能够创建恶意的web页面来伪造请求。这些伪造请求很难和合法的请求区分开。CSRF通过伪装来自受信任用户的请求来利用受信任的网站</p><h4 id="防范：-5"><a href="#防范：-5" class="headerlink" title="防范："></a>防范：</h4><ul><li>给每个HTTP请求添加一个不可预测的令牌，并保证该令牌对每个用户会话来说是唯一性。最好是将独有的令牌包含在隐藏字段中，通过HTTP请求发送，避免在URL中暴露出来。</li><li>要去用户重新认证或者判断他们是一个真实的用户</li></ul><h4 id="操作步骤-7"><a href="#操作步骤-7" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>第一步也是最实际的 CSRF 解决方案就是实现唯一、操作层面的标识。所以每次用户尝试执行某个操作的时候，会生成新的标识并在服务端校验。</li><li>唯一标识应该不能被轻易由攻击者猜测，所以它们不能将其包含在 CSRF 页面中。随机生成是个好的选择。</li><li>在每个可能为 CSRF 目标的表单中包含要发送的标识。“添加到购物车”请求、密码修改表单、邮件、联系方式或收货信息管理，以及银行的转账页面都是很好的例子。</li><li>标识应该在每次请求中发送给服务器。这可以在 URL 中实现，或者任何其它变量或者隐藏字段，都是推荐的。</li><li>验证码的使用也可以防止 CSRF。</li><li>同样，在一些关键操作中询问重新授权也是个最佳实践，例如，银行应用中的转账操作。</li></ul><h4 id="工作原理-7"><a href="#工作原理-7" class="headerlink" title="工作原理"></a>工作原理</h4><p>防止 CSRF 完全是确保验证过的用户是请求操作的人。由于浏览器和 Web 应用的工作方式，最佳实践是使用标识来验证操作，或者可能的情况下使用验证码来控制。</p><p>由于攻击者打算尝试破解标识的生成，或者验证系统，以一种攻击者不能猜测的方式，安全地生成它们非常重要。而且要使它们对每个用户和每个操作都唯一，因为复用它们会偏离它们的目的。</p><p>验证码控制和重新授权有时候会非常麻烦，使用户反感。但是如果操作的重要性值得这么做，用户可能愿意接受它们来换取额外的安全级别。</p><h2 id="9-使用含有已知漏洞的组件"><a href="#9-使用含有已知漏洞的组件" class="headerlink" title="9. 使用含有已知漏洞的组件"></a>9. 使用含有已知漏洞的组件</h2><p>开发人员使用的组件也会含有漏洞，这些漏洞能够被自动化工具发现和利用。然后攻击者根据需要定制攻击代码并实施攻击。</p><h4 id="防范：-6"><a href="#防范：-6" class="headerlink" title="防范："></a>防范：</h4><ul><li>标识正在使用的所有组件和版本，包括所有依赖项</li><li>及时关注这些组件的安全信息并保证他们是最新的。</li><li>建立使用组件的安全策略，禁止使用未经安全评估的组件。</li><li>在适当情况下，对组件进去安全封装，精简不必要的功能。封装易受攻击的部分</li></ul><h4 id="操作步骤-8"><a href="#操作步骤-8" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>第一个建议是，优先选择受支持和广泛使用的知名软件。</li><li>为你的应用所使用的三方组件保持安全更新和补丁的更新。</li><li>用于搜索一些特定组件的漏洞的好地方就是厂商的网站：它们通常拥有“发布说明”部分，其中它们会公布它们纠正了哪个 bug 或漏洞。这里我们可以寸照我们所使用的（或更新的）版本，并且插件是否有有已知的问题没有打补丁。</li><li>同样，厂商通常拥有安全建议站点，例如 <a href="https://technet.microsoft.com/library/security/" target="_blank" rel="noopener">Microsoft</a>，<a href="https://developer.joomla.org/security-centre.html" target="_blank" rel="noopener">Joomla</a>，<a href="http://www.oracle.com/technetwork/topics/security/alerts-086861.html" target="_blank" rel="noopener">Oracle</a>。我们可以使用它们来保持我们用于应用的软件的更新。</li><li>也有一些厂商无关的站点，它们致力于通知我们漏洞和安全问题。有个非常好的网站，集中了多个来源的信息，是<a href="http://www.cvedetails.com/" target="_blank" rel="noopener">CVE Details</a>。这里我们可以搜索多数厂商或产品，或者列出所有已知漏洞（至少是拥有 CVE 号码的漏洞），并且按照年份、版本和 CVSS 分数排列。</li><li>同时，黑客发布利用和发现的站点也是个获得漏洞和我们所使用的软件的信息的好地方。最流行的是 <a href="https://www.exploit-db.com/" target="_blank" rel="noopener">Exploit DB</a>。 <a href="http://seclists.org/fulldisclosure/" target="_blank" rel="noopener">Full disclosure 邮件列表</a>，以及 <a href="https://packetstormsecurity.com/files/" target="_blank" rel="noopener">Packet Storm 的文件部分</a>。</li><li>一旦我们发现了我们软件组件中的漏洞，我们必须评估它是否对我们的应用必要，或者需要移除。如果不能这样，我们需要尽快打补丁。如果没有可用的补丁或变通方案，并且漏洞是高危的，我们必须开始寻找组件的替代。</li></ul><h4 id="工作原理-8"><a href="#工作原理-8" class="headerlink" title="工作原理"></a>工作原理</h4><p>考虑在我们的应用中使用三方软件组件之前，我们需要查看它的安全信息，并了解，我们所使用的组件是否有更稳定更安全的版本或替代。</p><p>一旦我们选择了某个，并且将其包含到我们的应用中，我们需要使其保持更新。有时它可能涉及到版本改动以及没有后向兼容，但是这是我们想要维持安全的代价。如果我们不能更新或为高危漏洞打补丁，我们还可以使用 WAF（Web 应用防火墙）和IPS（入侵检测系统）来防止攻击。</p><p>除了在执行渗透测试的时候比较实用，下载和漏洞发布站点可以被系统管理员利用，用于了解可能出现什么攻击，它们的原理，以及如何保护应用避免它们。</p><h2 id="10-未验证的重定向和转发"><a href="#10-未验证的重定向和转发" class="headerlink" title="10. 未验证的重定向和转发"></a>10. 未验证的重定向和转发</h2><p>应用程序经常将用户重定向到其他网页，或以类似的方式进行内部转发。当目标网页是通过一个未验证的参数来指定时，就容易被攻击者利用。攻击者通过诱使受害人去点击未经验证的重定向链接，从而利用不安全的转发绕过安全检测。攻击者通过重定向可以试图安装恶意软件或者诱使受害人泄露密码等敏感信息，通过转发可以绕过访问控制。</p><h4 id="防范：-7"><a href="#防范：-7" class="headerlink" title="防范："></a>防范：</h4><ul><li>避免使用重定向和转发</li><li>如果使用了重定向和转发，则不要在确定目标时涉及到用户参数。</li><li>如果无法避免使用目标参数，则应确保目标参数值对于当前用户是有效的并已授权。</li></ul><h4 id="操作步骤-9"><a href="#操作步骤-9" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul><li>不希望存在漏洞吗？那就不要使用它。无论怎样，都不要使用重定向和转发。</li><li>如果需要使用重定向，尝试不要使用用户提供的参数（请求变量）来计算出目标。</li><li>如果需要使用参数，实现一个表，将其作为重定向的目录，使用 ID 代替 URL 作为用户应该提供的参数。</li><li>始终验证重定向和转发操作涉及到的输入。使用正则表达式或者白名单来检查提供的值是否有效。</li></ul><h4 id="工作原理-9"><a href="#工作原理-9" class="headerlink" title="工作原理"></a>工作原理</h4><p>重定向和转发是钓鱼者和其它社会工程师最喜欢用的工具，并且有时候我们对目标没有任何安全控制。所以，即使它不是我们的应用，它的安全问题也会影响我们的信誉。这就是最好不要使用它们的原因。</p><p>如果这种重定向的目标是已知站点，例如 Fackbook 或 Google，我们就可以在配置文件或数据表中建立目标目录，并且不需要使用客户端提供的参数来实现。</p><p>如果我们构建包含所有允许的重定向和转发 URL 的数据表，每个都带有 ID，我们可以将 ID 用于参数，而不是目标本身。这是一种白名单的形式，可以防止无效目标的插入。</p><p>最后同样是校验。我们始终要校验每个来自客户端的输入，这非常重要，因为我们不知道用户要输入什么。如果我们校验了重定向目标的正确性，除了恶意转发或重定向之外，我们还可以防止可能的 SQL 注入、XSS或者目录遍历。所以，它们都是相关的。</p>]]></content>
    
    
    <categories>
      
      <category>secuirty</category>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><ol><li><p>进程与线程的概念，区别</p><ul><li><p>进程：对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发，资源分配最小单位。</p></li><li><p>线程：进程的子任务，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p></li></ul><ul><li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p></li><li><p>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（推存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p></li><li><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p></li><li><p>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p></li><li><p>通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p></li><li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p></li><li><p>进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p></li><li><p>进程适应于多核、多机分布；线程适用于多核。</p></li></ul></li><li><p>OS缺页置换算法</p><p> FIFO算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排序成队列，从队尾进入，从队首删除。</p><p> LRU算法：置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p></li><li><p>死锁发生的条件/如何解决死锁</p><p> 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><ul><li><p>互斥条件：进程对所分配的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有资源的进程使用完成后释放该资源。</p></li><li><p>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</p></li><li><p>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。</p></li><li><p>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形锁。</p><p><b>解决方案：</b></p><p>资源一次性分配，从而剥夺请求和保持条件可剥夺资源：即当进程新的资源为获得满足时，释放已占有的资源，从而破坏不可剥夺的条件<br>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件。</p></li></ul></li><li><p>线程同步的几种方式：</p><ul><li><p>临界区：<br>  通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p></li><li><p>互斥量：<br>  采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p></li><li><p>信号量：<br>  为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p></li><li><p>事件（wait/notify）<br>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p></li></ul></li></ol><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><ol><li><p>互斥锁机制</p><ul><li><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p></li><li><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p><p><b>互斥锁和读写锁的区别</b></p></li><li><p>读写锁区分读者和写者，而互斥锁不区分</p></li><li><p>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间只允许一个写者，但是允许多个读者同时读该对象。</p></li></ul></li><li><p>Linux的四种锁机制：</p><p> 上面两种再加上：</p><ul><li><p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p></li><li><p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p></li></ul></li><li><p>软链接与硬链接区别</p><p> 为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p></li><li><p>大端小端区别以及如何判断</p><p> 大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p><pre><code class="cpp"> #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) {     union {         short s;         char c[sizeof(short)];     } un;     un.s = 0x0102;     if(sizeof(short)==2) {         if(un.c[0]==1 &amp;&amp; un.c[1] == 2)             printf(&quot;big-endian\n&quot;);         else if (un.c[0] == 2 &amp;&amp; un.c[1] == 1)             printf(&quot;little-endian\n&quot;);         else             printf(&quot;unknown\n&quot;);     } else         printf(&quot;sizeof(short)= %d\n&quot;,sizeof(short));     exit(0); }</code></pre></li><li><p>进程间通信的方式</p><ul><li><p>管道：</p><p>  管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><ul><li><p>普通管道PIPE：</p><p>  它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>  它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>  它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li><li><p>命名管道FIFO：</p><p>  FIFO可以在无关的进程之间交换数据</p><p>  FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li></ul></li><li><p>消息队列</p><p>  消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>  消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>  消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p></li><li><p>信号量semaphore</p><p>  信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于    存储进程间通信数据。</p><p>  信号量用于进程间同步，若要在进程间传递数" srcset="/img/loading.gif<img src="" alt="">据需要结合共享内存。</p><p>  信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。</p><p>  每次对信号量的PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>  支持信号量组。</p></li><li><p>事件（信号），Wait/Notify:</p><p>  通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p></li></ul></li></ol><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><ol><li><p>进程状态转换图</p><ul><li><p>进程的五种基本状态：<img src="/img/process_phrase.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等地I/O，等待设备，而暂时不能运行</li><li>终止状态：进程运行完毕</li></ul></li><li><p>交换技术：当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/O速度比处理剂速度慢得多，可能出现全部进程阻塞等待I/O。</p><p>  针以上问题，提出了两种解决方法：</p><ul><li><p>交换技术：换出一部分进程到外存，腾出内存空间</p></li><li><p>虚拟存储技术：每个进程只能装入一部分程序和数据</p><p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p><p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p></li></ul></li><li><p>活动阻塞，静止阻塞，活动就绪，静止就绪</p><ul><li><p>活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p></li><li><p>静止阻塞：进程在外存，同时被某种原因阻塞了。</p></li><li><p>活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p></li><li><p>静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p><p>从而出现了：</p><p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p><p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p><p>执行     ——  静止就绪         （时间片用完）</p></li></ul></li></ul></li><li><p>程序内存管理</p><p> 一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p><p> <img src="/img/memory_management.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p></li><li><p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p></li><li><p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p></li><li><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p></li><li><p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p></li><li><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p></li><li><p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p></li><li><p>可执行程序在运行时又多出两个区域：栈区和堆区。</p></li><li><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p></li><li><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p></li></ul></li><li><p>C++继承和虚函数</p><p> C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p><p> 动态多态实现有几个条件：</p><ul><li><p>虚函数</p></li><li><p>一个基类指针或引用指向派生类的对象</p><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p></li></ul></li></ol><ol start="4"><li><p>static修饰符和virtual修饰符</p><ul><li><p>static修饰符</p><ul><li><p>static修饰成员变量：</p><p>  对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p><p>  因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p></li><li><p>static修饰成员函数<br>  与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p><p>  Static修饰的成员函数，在代码区分配内存。</p></li></ul></li><li><p>virtual修饰符</p><p>  如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p><p>  如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。<br>  如果类中成员是virtual属性，会隐藏父类对应的属性。<br>  <img src="/img/virtual.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ol><ol start="5"><li><p>静态变量初始化</p><ul><li>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</li></ul></li><li><p>用户态和内核态区别</p><ul><li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</li></ul></li><li><p>内存溢出和内存泄露</p><ul><li><p>内存溢出</p><p>  指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p></li><li><p>内存溢出的原因：</p><p>  内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p><p>  集合类中有对对象的引用，使用完后未清空，使得不能回收</p><p>  代码中存在死循环或循环产生过多重复的对象实体</p><p>  使用的第三方软件中的BUG</p><p>  启动参数内存值设定的过小</p></li><li><p>内存泄露</p><p>  内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p></li><li><p>内存泄漏的分类：</p><ul><li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li><li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li></ul></li></ul></li><li><p>常用的线程模型</p></li></ol><ul><li><p>Future模型</p><p>  该模型通常在使用的时候需要结合Callable接口配合使用。</p><p>  Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p><p>  Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p></li><li><p>fork&amp;join模型</p><p>  该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p><p>  这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p></li><li><p>actor模型</p><p>  actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p></li><li><p>生产者消费者模型</p><p>  生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p></li><li><p>master-worker模型</p><p>  master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p></li></ul><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><ol><li><p>系统调用</p><ul><li><p>概念：</p><p>  在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p><p>  操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p><p>  应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p></li><li><p>系统调用举例：</p><p>  对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main(int argc, char *argv[]){  if (argc&lt;2)      return 0;  //用读写追加方式打开一个已经存在的文件  int fd = open(argv[1], O_RDWR | O_APPEND);  if (fd == -1)  {      printf(&quot;error is %s\n&quot;, strerror(errno));  }  else  {      //打印文件描述符号      printf(&quot;success fd = %d\n&quot;, fd);      char buf[100];      memset(buf, 0, sizeof(buf));      strcpy(buf, &quot;hello world\n&quot;);      write(fd, buf, strlen(buf));      close(fd);  }  return 0;}</code></pre><p>还有写数据write，创建进程fork，vfork等都是系统调用。</p></li></ul></li><li><p>用户态切换到内核态的3钟方法：</p><ul><li><p>系统调用</p><p>  这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p></li><li><p>异常</p><p>  当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p></li><li><p>外围设备的中断</p><p>  当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></li></ul></li><li><p>切换操作</p><p> 从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p><ul><li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li><li>使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li><li>将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li></ul></li><li><p>链接</p><p> 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ul><li><p>静态链接</p><p>  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p></li><li><p>动态链接</p><p>  动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p><p>  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p></li></ul></li><li><p>5种IO模型</p><ul><li>阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li>非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</li><li>信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li>IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li>异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul></li><li><p>多线程的同步， 锁的机制</p><ul><li>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</li></ul></li><li><p>线程池</p><ul><li>设置一个生产者消费者队列，作为临界资源</li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li><li>当任务队列为空的时候，所有线程阻塞</li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/17/hello-world/"/>
    <url>/2020/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
